{"version":3,"file":"index.cjs.js","sources":["../src/tag/types.ts","../src/tag/index.ts","../src/context/index.ts","../src/definer/index.ts","../src/utils/index.ts","../src/history/index.ts","../src/document/index.ts","../src/operators/index.ts","../src/hooks/change/index.ts","../src/hooks/mount/index.ts"],"sourcesContent":["import type { BehaviorSubject, Subject } from 'rxjs'\r\n\r\n\r\ninterface ObjectLiteral {\r\n  [key: string]: unknown\r\n}\r\n\r\nexport interface VDOM {\r\n  name: string\r\n  id: string\r\n  attrs: ObjectLiteral\r\n  children: VDOM[]\r\n}\r\n\r\nexport interface HistoryConfig {\r\n  enabled: boolean\r\n  __batch: boolean\r\n  // __batchedRecords: number\r\n  __ignoreNextUpdate: boolean\r\n}\r\n\r\nexport interface ITag {\r\n  parent: ITag | null\r\n  userData: ObjectLiteral\r\n\r\n  readonly history: HistoryConfig\r\n  readonly data: BehaviorSubject<unknown>\r\n\r\n  readonly id: string\r\n  readonly name: string\r\n\r\n  get historyBatch() : boolean\r\n  set historyBatch(value: boolean)\r\n\r\n  get vdom() : VDOM\r\n\r\n  get isMounted() : boolean\r\n  set isMounted(mounted: boolean)\r\n\r\n  get events() : MountObserver<ITagData>\r\n  get rx(): BehaviorSubject<ITagData>\r\n\r\n  get path() : string[] | null\r\n  findByPath(path: string[]) : ITag | null\r\n  \r\n  findById(id: string, recursive?: boolean) : ITag | null\r\n  findByName(name: string, recursive?: boolean) : ITag | null\r\n  find(fn: (child: ITag) => boolean, recursive?: boolean) : ITag | null\r\n\r\n  getRoot() : ITag | null\r\n\r\n  addChild(...childList: ITag[]) : void\r\n  removeChild(child: ITag | ITag[]) : boolean\r\n\r\n  filterChild(fn: (child: ITag) => boolean) : void\r\n\r\n  remove() : boolean\r\n\r\n  traverse(fn: (Tag: ITag) => void) : void\r\n}\r\n\r\nexport interface ITagData {\r\n  attrs: ObjectLiteral\r\n  children: ITag[]\r\n}\r\n\r\nexport type InitiatorFunction<TagObject> = (Tag: TagObject) => void\r\n\r\nexport enum EventTypes {\r\n  change,\r\n  mount,\r\n  unmount,\r\n  treeUpdate\r\n}\r\n\r\nexport interface ChangeEvent<Type extends ITagData> {\r\n  type: EventTypes.change\r\n  prev: Type\r\n  next: Type\r\n}\r\n\r\nexport interface TreeUpdateEvent {\r\n  type: EventTypes.treeUpdate\r\n  tag: ITag\r\n  event: ChangeEvent<ITagData>\r\n}\r\n\r\nexport interface MountEvent {\r\n  type: EventTypes.mount | EventTypes.unmount\r\n}\r\n\r\nexport type MountObserver<Type extends ITagData> = Subject<ChangeEvent<Type> | TreeUpdateEvent | MountEvent>\r\n\r\n\r\nexport type TagMap = {[key: string]: ITag}\r\n\r\nexport type NoAttrs = Record<string, never>\r\n\r\n","import { BehaviorSubject, Subject, map, distinctUntilChanged, Subscription, filter, pairwise } from 'rxjs'\r\nimport { v4 as uuid } from 'uuid'\r\nimport { EventTypes } from './types'\r\nimport type { ITag, ITagData, VDOM, MountObserver, MountEvent, ChangeEvent, TreeUpdateEvent, InitiatorFunction, HistoryConfig } from './types'\r\nimport type { Unpacked } from '@/utils/packer'\r\n\r\n\r\n\r\nexport class Tag<DataType extends ITagData> implements ITag {\r\n  private readonly initiator: InitiatorFunction<this> | null = null\r\n\r\n  private mounted = false\r\n  private subscriptions: Subscription[] = []\r\n\r\n  protected eventObserver: MountObserver<DataType> = new Subject()\r\n\r\n  readonly data: BehaviorSubject<DataType>\r\n\r\n  readonly id: string\r\n  readonly name: string\r\n\r\n  readonly parent: ITag | null = null\r\n  readonly childKeys = new BehaviorSubject<string[]>([])\r\n\r\n  readonly history: HistoryConfig = {\r\n    enabled: true,\r\n    __batch: false,\r\n    // __batchedRecords: 0,\r\n    __ignoreNextUpdate: false,\r\n  }\r\n\r\n  userData = {}\r\n\r\n  constructor(props: Omit<VDOM, 'children'>, initiator?: InitiatorFunction<ITag>) {\r\n    Object.defineProperties(this, {\r\n      'initiator': {\r\n        value: initiator || null,\r\n        writable: false,\r\n        configurable: false,\r\n        enumerable: false,\r\n      },\r\n      'id': {\r\n        value: props.id || uuid(),\r\n        writable: false,\r\n        configurable: false,\r\n      },\r\n      'name': {\r\n        value: props.name,\r\n        writable: false,\r\n        configurable: false,\r\n      },\r\n    })\r\n\r\n    this.data = new BehaviorSubject<DataType>({\r\n      attrs: props.attrs,\r\n      children: [] as DataType['children'],\r\n    } as DataType)\r\n  }\r\n\r\n  protected __initialize() {\r\n    // Executes on mount\r\n\r\n    /** Update keys */\r\n    const onKeysUpdate = this.data\r\n      .pipe(map(({children}) => children), distinctUntilChanged())\r\n      .subscribe(children => {\r\n        this.childKeys.next(children.map(child => child.id))\r\n      })\r\n\r\n    /** On tree update event, pass up */\r\n    const onTreeUpdate = this.eventObserver\r\n      .pipe(filter(({type}) => type === EventTypes.treeUpdate))\r\n      .subscribe((e: TreeUpdateEvent) => {\r\n        if (!this.history.enabled || this.history.__batch) {\r\n          if (e.tag !== this) {\r\n            // If we batch, then ignore child event in the History processor\r\n            e.tag.history.__ignoreNextUpdate = true\r\n          }\r\n          // else {\r\n          //   this.history.__batchedRecords++\r\n          // }\r\n        }\r\n\r\n        if (this.parent) {\r\n          (this.parent as Tag<ITagData>).eventObserver.next(e)\r\n        }\r\n      })\r\n\r\n    /** On change event */\r\n    const onChange = this.data\r\n      .pipe(pairwise())\r\n      .subscribe((values: DataType[]) => {\r\n        const event : ChangeEvent<DataType> = {\r\n          type: EventTypes.change,\r\n          prev: values[0],\r\n          next: values[1],\r\n        }\r\n\r\n        // Emit change event\r\n        this.eventObserver.next(event)\r\n\r\n        // Emit treeUpdate event\r\n        this.eventObserver.next({\r\n          type: EventTypes.treeUpdate,\r\n          tag: this,\r\n          event,\r\n        })\r\n      })\r\n\r\n    this.addSubscription(onKeysUpdate)\r\n    this.addSubscription(onTreeUpdate)\r\n    this.addSubscription(onChange)\r\n  }\r\n\r\n  get historyBatch() : boolean {\r\n    return this.history.__batch\r\n  }\r\n\r\n  set historyBatch(value: boolean) {\r\n    const isChanged = this.historyBatch !== value\r\n\r\n    if (isChanged) {\r\n      if (value) {\r\n        const next = {\r\n          attrs: this.attrs,\r\n          children: this.children,\r\n        } as DataType\r\n    \r\n        this.data.next(next)\r\n      }\r\n\r\n      this.history.__batch = value\r\n\r\n      if (!value) {\r\n\r\n        // Poor udate to fix history in case of Batch end\r\n        const next = {\r\n          attrs: this.attrs,\r\n          children: this.children,\r\n        } as DataType\r\n    \r\n        this.data.next(next)\r\n      }\r\n    }\r\n  }\r\n\r\n  get path(): string[] | null {\r\n    if (!this.isMounted) {\r\n      return null\r\n    }\r\n\r\n    if (!this.parent) {\r\n      return []\r\n    }\r\n\r\n    return [\r\n      ...(this.parent.path as []),\r\n      this.id,\r\n    ]\r\n  }\r\n\r\n  get isMounted() {\r\n    return this.mounted\r\n  }\r\n\r\n  protected set isMounted(mounted: boolean) {\r\n    if (mounted !== this.mounted) {\r\n      for (const child of this.children) {\r\n        child.isMounted = mounted\r\n      }\r\n\r\n      if (!mounted) {\r\n        this.eventObserver.next({type: EventTypes.unmount})\r\n        for (const sub of this.subscriptions) {\r\n          sub.unsubscribe()\r\n        }\r\n        this.subscriptions.splice(0, this.subscriptions.length)\r\n        this.userData = {}\r\n      } else {\r\n        this.__initialize()\r\n        this.initiator && this.initiator(this)\r\n        this.eventObserver.next({type: EventTypes.mount})\r\n      }\r\n\r\n      this.mounted = mounted\r\n    }\r\n  }\r\n\r\n  get attrs() : DataType['attrs'] {\r\n    return this.data.value.attrs\r\n  }\r\n\r\n  get children() : DataType['children'] {\r\n    return this.data.value.children\r\n  }\r\n\r\n  get rx() {\r\n    return this.data\r\n  }\r\n\r\n  get events() {\r\n    return this.eventObserver\r\n  }\r\n\r\n  findByPath(path: string[]) : ITag | null {\r\n    if (path.length === 0) {\r\n      return this\r\n    }\r\n\r\n    const last = path[0] as string\r\n\r\n    for (const child of this.children) {\r\n      if (child.id === last) {\r\n        return child.findByPath(path.slice(1))\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  findById(id: string, recursive = false) : ITag | null {\r\n    let result\r\n\r\n    for (const child of this.children) {\r\n      if (child.id === id) {\r\n        return child\r\n      }\r\n\r\n      if (recursive) {\r\n        if (result = child.findById(id)) {\r\n          return result\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  findByName(name: string, recursive = false) : ITag | null {\r\n    let result\r\n    \r\n    for (const child of this.children) {\r\n      if (child.name === name) {\r\n        return child\r\n      }\r\n\r\n      if (recursive) {\r\n        if (result = child.findByName(name)) {\r\n          return result\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  find(fn: (child: ITag) => boolean, recursive = false) : ITag | null {\r\n    let result\r\n    \r\n    for (const child of this.children) {\r\n      if (fn(child)) {\r\n        return child\r\n      }\r\n\r\n      if (recursive) {\r\n        if (result = child.find(fn)) {\r\n          return result\r\n        }\r\n      }\r\n    }\r\n\r\n    return null\r\n  }\r\n\r\n  getRoot() : ITag | null {\r\n    if (!this.parent) {\r\n      return null\r\n    }\r\n\r\n    return this.parent.getRoot()\r\n  }\r\n\r\n  get subscriptionsSize() {\r\n    return this.subscriptions.length\r\n  }\r\n\r\n  addSubscription(sub: Subscription) {\r\n    this.subscriptions.push(sub)\r\n  }\r\n\r\n  removeSubscription(sub: Subscription) {\r\n    this.subscriptions = this.subscriptions.filter(target => {\r\n      if (target === sub) {\r\n        sub.unsubscribe()\r\n        return false\r\n      }\r\n\r\n      return true\r\n    })\r\n  }\r\n\r\n  onUnmount(fn: (event: MountEvent) => void) : Subscription {\r\n    return this.eventObserver.pipe(filter(({type}) => type === EventTypes.unmount)).subscribe(fn)\r\n  }\r\n\r\n  onChange(fn: (event: ChangeEvent<DataType>) => void) : Subscription {\r\n    return this.eventObserver.pipe(filter(({type}) => type === EventTypes.change)).subscribe(fn)\r\n  }\r\n\r\n  onTreeUpdate(fn: (event: TreeUpdateEvent) => void) : Subscription {\r\n    return this.eventObserver.pipe(filter(({type}) => type === EventTypes.treeUpdate)).subscribe(fn)\r\n  }\r\n\r\n  setAttr<Key extends keyof DataType['attrs']>(name: Key, value: DataType['attrs'][Key]) {\r\n    const next = {\r\n      attrs: {\r\n        ...this.attrs,\r\n        [name]: value,\r\n      },\r\n      children: this.children,\r\n    } as DataType\r\n\r\n    this.data.next(next)\r\n  }\r\n\r\n  setAttrs(attrs: DataType['attrs']) {\r\n    const next = {\r\n      attrs: {...attrs},\r\n      children: this.children,\r\n    } as DataType\r\n\r\n    this.data.next(next)\r\n  }\r\n\r\n  addChild(...childList: DataType['children']) {\r\n    const nextChildren = [...this.children]\r\n\r\n    for (const child of childList) {\r\n      if (child.parent && child.parent !== this) {\r\n        child.parent.removeChild(child)\r\n      }\r\n\r\n      if (child.parent && child.parent === this) {\r\n        continue\r\n      }\r\n\r\n      nextChildren.push(child)\r\n\r\n      child.parent = this\r\n      child.isMounted = this.isMounted\r\n    }\r\n\r\n    const next = {\r\n      attrs: this.attrs,\r\n      children: nextChildren,\r\n    } as DataType\r\n\r\n    this.data.next(next)\r\n  }\r\n\r\n  removeChild(child: Unpacked<DataType['children']> | DataType['children']) {\r\n    const childArray = Array.isArray(child) ? child : [child]\r\n    const validChild = childArray\r\n      .filter(target => target.parent && (target.parent === this))\r\n      .map(target => {\r\n        target.parent = null\r\n        target.isMounted = false\r\n\r\n        return target.id\r\n      })\r\n\r\n    if (!validChild.length) {\r\n      return false\r\n    }\r\n    \r\n    const nextChild = this.children.filter(target => validChild.indexOf(target.id) === -1)\r\n\r\n    const next = {\r\n      attrs: this.attrs,\r\n      children: nextChild,\r\n    } as DataType\r\n\r\n    this.data.next(next)\r\n\r\n    return true\r\n  }\r\n\r\n  filterChild(fn: (child: Unpacked<DataType['children']>) => boolean) {\r\n    const childrenToRemove: ITag[] = []\r\n\r\n    const nextChild = this.children.filter(target => {\r\n      if (fn(target as Unpacked<DataType['children']>)) {\r\n        return true\r\n      }\r\n\r\n      childrenToRemove.push(target)\r\n      return false\r\n    })\r\n\r\n    const next = {\r\n      attrs: this.attrs,\r\n      children: nextChild,\r\n    } as DataType\r\n\r\n    for (const child of childrenToRemove) {\r\n      child.parent = null\r\n      child.isMounted = false\r\n    }\r\n\r\n    this.data.next(next)\r\n  }\r\n\r\n  remove() : boolean {\r\n    if (this.parent) {\r\n      return this.parent.removeChild(this)\r\n    }\r\n\r\n    return false\r\n  }\r\n\r\n  traverse(fn: (Tag: ITag) => void) : void {\r\n    for (const child of this.children) {\r\n      fn(child)\r\n      child.traverse(fn)\r\n    }\r\n  }\r\n\r\n  get vdom() : VDOM {\r\n    return {\r\n      name: this.name,\r\n      id: this.id,\r\n      attrs: this.attrs,\r\n      children: this.children.map(child => child.vdom),\r\n    }\r\n  }\r\n\r\n  toJSON() {\r\n    return this.vdom\r\n  }\r\n}\r\n\r\n","import type { ITag } from '@/tag/types'\r\nimport type { ITagContext } from './types'\r\n\r\nexport const TagContext : ITagContext = {\r\n  current: null,\r\n  get: function (): ITag | null {\r\n    return this.current\r\n  },\r\n  set: function (Tag: ITag | null): void {\r\n    this.current = Tag\r\n  },\r\n}","import { TagContext } from '@/context'\r\nimport { Tag } from '@/tag'\r\nimport type { ITagData, VDOM } from '@/tag/types'\r\nimport type { TagCreatorFunction } from './types'\r\n\r\nconst Registry: {[key: string]: TagCreatorFunction<ITagData>} = {}\r\n\r\nexport const clearRegistry = () => {\r\n  for (const key in Registry) {\r\n    delete Registry[key]\r\n  }\r\n}\r\n\r\nexport const create = (vdom: VDOM) : Tag<ITagData> | null => {\r\n  const children = []\r\n  for (const child of vdom.children) {\r\n    const inst = create(child)\r\n    if (inst) {\r\n      children.push(inst)\r\n    }\r\n  }\r\n\r\n  if (vdom.name in Registry) {\r\n    return Registry[vdom.name](vdom.id, vdom.attrs, children)\r\n  }\r\n\r\n  return null\r\n}\r\n\r\nexport const def = <Type extends ITagData>(\r\n  name: string,\r\n  initiator?: (Tag: Tag<Type>) => void,\r\n) : TagCreatorFunction<Type> => {\r\n  if (name in Registry) {\r\n    throw new Error(`Name ${name} already registered. Name should be a uniq string`)\r\n  }\r\n\r\n  const creator = (id: string | null = null, attributes: Type['attrs'] = {}, children: Type['children'] = []) : Tag<Type> => {\r\n    const targetInitiator = initiator && ((Tag: Tag<Type>) => {\r\n      TagContext.set(Tag)\r\n      initiator(Tag)\r\n      TagContext.set(null)\r\n    })\r\n\r\n    const instance = new Tag<Type>(\r\n      {\r\n        id: id || '',\r\n        name,\r\n        attrs: attributes,\r\n      },\r\n      targetInitiator,\r\n    )\r\n\r\n    if (children.length) {\r\n      instance.addChild(...children)\r\n    }\r\n\r\n    return instance\r\n  }\r\n\r\n  Registry[name] = creator\r\n\r\n  return creator\r\n}\r\n","import { ITagData, VDOM } from '@/tag/types'\r\nimport { Tag } from '@/tag'\r\nimport { create } from '@/definer'\r\n\r\ntype Mutable<Immutable> = {\r\n  -readonly [K in keyof Immutable]: Immutable[K] \r\n}\r\n\r\nexport const fromVDOM = (Tag: Tag<ITagData>, vdom: VDOM, ignoreHistory = false) : Tag<ITagData> | null => {\r\n  if (Tag.name !== vdom.name) {\r\n    return null\r\n  }\r\n\r\n  Tag.history.__ignoreNextUpdate = ignoreHistory\r\n\r\n  const nextChildren = []\r\n\r\n  const childrenToInsert: ITagData['children'] = []\r\n  const indicesToSave: number[] = []\r\n\r\n  const keys: string[] = Tag.childKeys.value\r\n\r\n  // Loop to search for new/old Tags\r\n  for (const child of vdom.children) {\r\n    const originIndex = keys.indexOf(child.id)\r\n    if (originIndex !== -1) {\r\n      /** Always ignore history for child udates */\r\n      const current = fromVDOM(Tag.children[originIndex] as Tag<ITagData>, child, true)\r\n      // Save indices of old instances that should be saved/updated\r\n      indicesToSave.push(originIndex)\r\n      nextChildren.push(current)\r\n    } else {\r\n      // Save Tags that will be inserted for the first time\r\n      const nextChild = create(child)\r\n\r\n      if (nextChild) {\r\n        /** Always ignore history for child udates */\r\n        const current = fromVDOM(nextChild as Tag<ITagData>, child, true) as Mutable<Tag<ITagData>>\r\n\r\n        childrenToInsert.push(current)\r\n        nextChildren.push(current)\r\n        current.parent = Tag\r\n      }\r\n    }\r\n  }\r\n\r\n\r\n  // Unmount removed\r\n  for (let childIndex = 0; childIndex < Tag.children.length; childIndex++) {\r\n    if (indicesToSave.indexOf(childIndex) !== -1) {\r\n      continue\r\n    }\r\n\r\n    const child = Tag.children[childIndex]\r\n\r\n    child.isMounted = false\r\n    child.parent = null\r\n  }\r\n\r\n  const next = {\r\n    attrs: vdom.attrs,\r\n    children: nextChildren,\r\n  } as ITagData\r\n\r\n  Tag.data.next(next)\r\n\r\n  // Mount Tags that were inserted for the first time\r\n  for (const child of childrenToInsert) {\r\n    child.isMounted = Tag.isMounted\r\n  }\r\n\r\n  return Tag\r\n}","import { RootDataType } from '@/document/types'\r\nimport { Tag } from '@/tag'\r\nimport { fromVDOM } from '@/utils'\r\nimport type { ITagData, TreeUpdateEvent, VDOM } from '@/tag/types'\r\nimport type { IHistory } from './types'\r\n\r\ntype HistorySlice = {\r\n  path: string[]\r\n  vdom: VDOM\r\n}\r\n\r\nexport class History<ChildType extends ITagData['children']> implements IHistory<ChildType> {\r\n  private stack: HistorySlice[] = []\r\n  private pointer = 0\r\n\r\n  size = 256\r\n\r\n  // private batchedTags: Map<string, HistorySlice> = new Map()\r\n\r\n  readonly owner: Tag<RootDataType<ChildType>>\r\n\r\n  constructor(root: Tag<RootDataType<ChildType>>) {\r\n    this.owner = root\r\n    this.stack.push({\r\n      path: root.path as string[],\r\n      vdom: root.vdom,\r\n    })\r\n  }\r\n\r\n  push(event: TreeUpdateEvent) : void {\r\n    if (!event.tag.history.enabled || event.tag.historyBatch) {\r\n      return\r\n    }\r\n\r\n    if (event.tag.history.__ignoreNextUpdate) {\r\n      event.tag.history.__ignoreNextUpdate = false\r\n      return\r\n    }\r\n\r\n    // Process event\r\n    this.stack.splice(this.pointer + 1, this.stack.length - this.pointer)// Remove future\r\n    this.stack.push({\r\n      path: event.tag.path as string[],\r\n      vdom: event.tag.vdom,\r\n    })// Push new state\r\n\r\n    if (this.stack.length > this.size) {\r\n      // Remove out of range slices\r\n      this.stack = this.stack.slice(this.stack.length - this.size)\r\n    }\r\n\r\n    this.pointer = this.stack.length - 1\r\n  }\r\n\r\n  undo(): boolean {\r\n    if (this.pointer <= 0) {\r\n      return false\r\n    }\r\n\r\n    const step = this.stack[--this.pointer]// Get prev\r\n    const tag = this.owner.findByPath(step.path)\r\n\r\n    if (tag) {\r\n      fromVDOM(tag as Tag<ITagData>, step.vdom, true)// Apply\r\n    }\r\n\r\n    return true\r\n  }\r\n\r\n  redo(): boolean {\r\n    if (this.pointer >= this.stack.length - 1) {\r\n      return false\r\n    }\r\n    \r\n    const step = this.stack[++this.pointer]// Get next\r\n    const tag = this.owner.findByPath(step.path)\r\n\r\n    if (tag) {\r\n      fromVDOM(tag as Tag<ITagData>, step.vdom, true)// Apply\r\n    }\r\n\r\n    return true\r\n  }\r\n  \r\n  clear() : void {\r\n    this.stack.splice(0, this.stack.length)\r\n    this.pointer = 0\r\n  }\r\n\r\n  jump(count: number): void {\r\n    const absCount = count < 0 ? (-count) : count\r\n    const fn = count < 0 ? this.undo.bind(this) : this.redo.bind(this)\r\n\r\n    for (let i = 0; i <= absCount; i++) {\r\n      fn()\r\n    }\r\n  }\r\n}","import { filter } from 'rxjs'\r\nimport { Tag } from '@/tag'\r\nimport { History } from '@/history'\r\nimport { EventTypes } from '@/tag/types'\r\nimport type { ITagData, TreeUpdateEvent, ITag } from '@/tag/types'\r\nimport type { IHistory } from '@/history/types'\r\nimport type { IDocument, RootDataType } from './types'\r\n\r\n\r\nexport class Document<ChildType extends ITagData['children']> extends Tag<RootDataType<ChildType>> implements IDocument<ChildType> {\r\n  historyManager: IHistory<ChildType>\r\n\r\n  constructor(name?: string, id?: string) {\r\n    super({name: name || 'Document', id: id || 'root', attrs: {}})\r\n    this.__initialize()\r\n\r\n    this.historyManager = new History(this)\r\n\r\n    /** One time bind, since document is always mounted */\r\n    this.eventObserver\r\n      .pipe(filter(({type}) => type === EventTypes.treeUpdate))\r\n      .subscribe((e: TreeUpdateEvent) => this.historyManager.push(e))\r\n  }\r\n\r\n  get isMounted(): boolean {\r\n    return true\r\n  }\r\n\r\n  getRoot() : ITag {\r\n    return this\r\n  }\r\n}","import { map } from 'rxjs'\r\nimport type { ITagData } from '@/tag/types'\r\n\r\nexport function attrOp<DataType extends ITagData>() {\r\n  return map((data: DataType) => data.attrs as DataType['attrs'])\r\n}\r\n\r\nexport function childOp<DataType extends ITagData>() {\r\n  return map((data: DataType) => data.children as DataType['children'])\r\n}","import { TagContext } from '@/context'\r\nimport { Tag } from '@/tag'\r\nimport { EventTypes } from '@/tag/types'\r\nimport type { ChangeEvent, ITagData } from '@/tag/types'\r\n\r\n\r\nexport const rxChange = (callback: (event: ChangeEvent<ITagData>) => void) : void => {\r\n  const component = TagContext.get() as Tag<ITagData>\r\n\r\n  if (!component) {\r\n    throw new Error('rxMount hook is out of the component')\r\n  }\r\n\r\n  const sub = component.events.subscribe((event) => {\r\n    if (event.type === EventTypes.change) {\r\n      // Mount\r\n      callback(event)\r\n    }\r\n  })\r\n\r\n  component.addSubscription(sub)\r\n}","import { TagContext } from '@/context'\r\nimport { Tag } from '@/tag'\r\nimport { EventTypes } from '@/tag/types'\r\nimport type { ITagData } from '@/tag/types'\r\n\r\ntype cleanUp = () => void\r\ninterface CleanupRef {\r\n  current: cleanUp | null\r\n}\r\n\r\nexport const rxMount = (callback: () => cleanUp) : void => {\r\n  const component = TagContext.get() as Tag<ITagData>\r\n\r\n  if (!component) {\r\n    throw new Error('rxMount hook is out of the component')\r\n  }\r\n\r\n  const fnRef: CleanupRef = {\r\n    current: null,\r\n  }\r\n\r\n  const sub = component.events.subscribe((event) => {\r\n    if (event.type === EventTypes.mount) {\r\n      // Mount\r\n      fnRef.current = callback()\r\n    } else if (event.type === EventTypes.unmount && fnRef.current) {\r\n      // Unmount\r\n      fnRef.current()\r\n      fnRef.current = null\r\n    }\r\n  })\r\n\r\n  component.addSubscription(sub)\r\n}"],"names":["EventTypes","Tag","constructor","props","initiator","this","mounted","subscriptions","eventObserver","Subject","parent","childKeys","BehaviorSubject","history","enabled","__batch","__ignoreNextUpdate","userData","Object","defineProperties","value","writable","configurable","enumerable","id","uuid","name","data","attrs","children","__initialize","onKeysUpdate","pipe","map","distinctUntilChanged","subscribe","next","child","onTreeUpdate","filter","type","treeUpdate","e","tag","onChange","pairwise","values","event","change","prev","addSubscription","historyBatch","path","isMounted","mount","unmount","sub","unsubscribe","splice","length","rx","events","findByPath","last","slice","findById","recursive","result","findByName","find","fn","getRoot","subscriptionsSize","push","removeSubscription","target","onUnmount","setAttr","setAttrs","addChild","childList","nextChildren","removeChild","validChild","Array","isArray","nextChild","indexOf","filterChild","childrenToRemove","remove","traverse","vdom","toJSON","TagContext","current","get","set","Registry","create","inst","fromVDOM","ignoreHistory","childrenToInsert","indicesToSave","keys","originIndex","childIndex","History","root","stack","pointer","size","owner","undo","step","redo","clear","jump","count","absCount","bind","i","super","historyManager","key","Error","creator","attributes","targetInitiator","instance","callback","component","fnRef"],"mappings":"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"}